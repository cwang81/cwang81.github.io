{"pages":[{"title":"About me","text":"ðŸŽ‰ Code for fun! ðŸŽ‰ I am currently a Ph.D. candidate at University of Houston.My research focus is on computational catalysis and reaction modeling. I love coding/hiking/video games!This blog is used to record my ideas and LeetCode questions.Hope you have fun here!!!","link":"/about/me.html"}],"posts":[{"title":"LC 254. Factor Combinations","text":"https://leetcode.com/problems/factor-combinations/ Clarification &amp; AssumptionDescription: Giving a number n, return all possible combinations of its factors input: int n output: List&lt;List&lt;Integer&gt;&gt; for all the possible cases: e.g. n = 1, return [] n = 12, return [[2,6], [3,4], [2,2,3]] Resulthigh level: dfs there are 2 ways to do dfs for this problem 1. add one factor at each level 12 / | | \\ 2 0 2 2x2 2x2x2 / \\ / \\ | 3 0 3 0 3 3 / \\ 4 ... we can add one factor at each level as only using one factor at each level, duplicate results are avoided # of levels: sqrt(n) in maximum each level represent: # of factors added at current level # of states: n / level TC: O(logn^sqrt(n)) SC: O(logn^sqrt(n)) 2. add multiple factors at each level 12 / | | \\ 2 3 4 6 / \\ | 2 3 4 we can also vary the factor at each level but the deduplicate, we need to keep the next level factors larger than the current one we choose e.g. otherwise, such factor combination could happen: 3-&gt;2-&gt;2, which is the same as 2-&gt;2-&gt;3 # of levels: logn each level represent: which factor to be added # of states: sqrt(n) TC: O(sqrt(n)^logn) SC: O(sqrt(n)^logn) here I chose the 2nd approach, because if n is large, logn &lt; sqrt(n) here is an image showing the trend: Test cases:corner case: &lt;= 1 -&gt; return empty list general cases: 2, 4, 12, 24, 37, 55, 101, 1000000 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; getFactors(int n) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(n, 2, new ArrayList&lt;&gt;(), res); return res;}private void dfs(int n, int factor, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) { // base case if (n &lt;= 1) return; for (int i = factor; i * i &lt;= n; i++) { if (n % i == 0) { list.add(i); list.add(n / i); res.add(new ArrayList&lt;&gt;(list)); list.remove(list.size() - 1); dfs(n / i, i, list, res); list.remove(list.size() - 1); } }}","link":"/2021/08/10/factor-combinations/"},{"title":"LC 1396. Design Underground System","text":"https://leetcode.com/problems/design-underground-system/ Clarification &amp; AssumptionDescription: design an underground railway system that keeps track of customer travel times between different stations functions: 1. void checkIn(int id, String stationName, int t) customer with id check in stationName at time t 2. void checkOut(int id, String stationName, int t) customer with id check out stationName at time t 3. double getAverageTime(String startStation, String endStation) calculate the average time it takes to traverl from start to end stations Result:high level: 2 HashMaps use a HashMap to store the id &amp; checkInData Map&lt;Integer, CheckInfo&gt; checkInData use another HashMap to store the startStation-&gt;endStation, &amp; the TimeInfo Map&lt;String, TimeInfo&gt; averageTimes here I used 2 helper classes, CheckInfo and TimeInfo checkInfo stores the check in station &amp; time TimeInfo stores the totalTime to travel from start-&gt;end station &amp; counts of travels 12345678910111213141516171819private static class CheckInfo { String station; int time; public CheckInfo(String station, int time) { this.station = station; this.time = time; }}private static class TimeInfo { int totalTime; int occurrence; public TimeInfo(int totalTime, int occurrence) { this.totalTime = totalTime; this.occurrence = occurrence; }} * when checkIn is called, put the id &amp; checkInfo into the checkInData HashMap * when checkOut is called, get the checkInfo using given id and calculate the travel time, put the stations &amp; TimeInfo into the averageTimes HashMap * when getAverageTime is called, simply get the TimeInfo from averageTimes HashMap and do a math calculation to get the averageTime 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class UndergroundSystem { Map&lt;Integer, CheckInfo&gt; checkInData; Map&lt;String, TimeInfo&gt; averageTimes; public UndergroundSystem() { checkInData = new HashMap&lt;&gt;(); averageTimes = new HashMap&lt;&gt;(); } // TC: O(1) public void checkIn(int id, String stationName, int t) { checkInData.put(id, new CheckInfo(stationName, t)); } // TC: O(1) public void checkOut(int id, String stationName, int t) { CheckInfo checkInfo = checkInData.get(id); checkInData.remove(id); String stations = checkInfo.station + &quot;,&quot; + stationName; if (!averageTimes.containsKey(stations)) { averageTimes.put(stations, new TimeInfo(0, 0)); } int timeTaken = t - checkInfo.time; int occurrence = averageTimes.get(stations).occurrence + 1; int totalTime = averageTimes.get(stations).totalTime + timeTaken; averageTimes.put(stations, new TimeInfo(totalTime, occurrence)); } // TC: O(1) public double getAverageTime(String startStation, String endStation) { TimeInfo timeInfo = averageTimes.get(startStation + &quot;,&quot; + endStation); return (double)(timeInfo.totalTime + 0.0) / timeInfo.occurrence; } private static class CheckInfo { String station; int time; public CheckInfo(String station, int time) { this.station = station; this.time = time; } } private static class TimeInfo { int totalTime; int occurrence; public TimeInfo(int totalTime, int occurrence) { this.totalTime = totalTime; this.occurrence = occurrence; } }}","link":"/2021/08/10/design-underground-system/"},{"title":"K Smallest In Unsorted Array","text":"Clarification &amp; Assumption:Input &amp; Output (signature): i. input: int[] array, int k ii. output: int[], k smallest in ascending order For all the possible cases: input not sorted k &gt;=0, k &lt;= input.length array not null corner case: array == [], k == 0 â†’ return empty array Result:high level: 1. bfs, maxHeap (less space than minHeap) 2. quick select Queue&lt;Integer&gt; maxHeap; i = 0 to k-1 â†’ maxHeap.offer(array[i]); i = k to array.length - 1: if smaller than maxHeap.peek(); maxHeap.poll(); maxHeap.offer(array[i]); int[] result; put all numbers from maxHeap to result; Complexity analysis: TC: O(k + (n-k)logk) SC: O(k) Test cases:i. Test corner case: length == 0, k == 0 â†’ return empty array ii. Test general case: 9 1 2 7 8 5 3, k = 0/1/2/3/4, etc. 1. Priority Queue12345678910111213141516171819202122public int[] kSmallest(int[] array, int k) { if (array.length == 0 || k == 0) { return new int[0]; } Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(k, (Integer i1, Integer i2) -&gt; i1.equals(i2) ? 0 : i1 &gt; i2 ? -1 : 1); for (int i = 0; i &lt; array.length; i += 1) { if (i &lt; k) { maxHeap.offer(array[i]); } else { if (array[i] &lt; maxHeap.peek()) { maxHeap.poll(); maxHeap.offer(array[i]); } } } int[] result = new int[k]; for (int i = k - 1; i &gt;= 0; i -= 1) { result[i] = maxHeap.poll(); } return result;} 2. Quick SelectComplexity analysis: TC: O(n) = n + n/2 + n/4 + â€¦ + 1 worse case: O(n^2) SC: O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445public int[] kSmallest(int[] array, int k) { if (array.length == 0 || k == 0) { return new int[0]; } int left = 0; int right = array.length - 1; while (left &lt; right) { int index = partition(array, left, right); if (index &lt; k - 1) { left = index + 1; } else if (index &gt; k - 1) { right = index - 1; } else { break; } } int[] result = Arrays.copyOf(array, k); Arrays.sort(result); return result;}private int partition(int[] array, int left, int right) { int pivotIndex = left + (int)(Math.random() * (right - left + 1)); int pivot = array[pivotIndex]; swap(array, pivotIndex, right); int i = left; int j = right - 1; while (i &lt;= j) { if (array[i] &lt; pivot) { i++; } else if (array[j] &gt;= pivot) { j--; } else { swap(array, i++, j--); } } swap(array, i, right); return i;}private void swap(int[] array, int index1, int index2) { int tmp = array[index1]; array[index1] = array[index2]; array[index2] = tmp;}","link":"/2021/08/08/k-smallest-in-unsorted-array/"},{"title":"Hello World","text":"Hello World!","link":"/2021/08/08/hello-world/"},{"title":"LC 90. SubSets II","text":"https://leetcode.com/problems/subsets-ii/ Clarification &amp; Assumption:Description: given an integer array, find all possible subsets e.g. [1,2,2] -&gt; [1], [2], [1,2], [2,2], [1,2,2] Input &amp; Output: i. input: String set ii. output: List&lt;String&gt; For all the possible cases: there could be duplicate characters Result:high level: DFS i. sort the characters in ascending order to make the duplicate character next to each other ii. DFS backtracking abb â†’ '', a, b, ab, bb, abb '' / \\ 0 a '' / \\ / \\ 1 ab a b '' / \\ \\ / \\ \\ 2 abb ab a bb b '' unliked the subset i problem, here it contains duplicate results one naive approach is to use a HashMap and deduplicate the results when we get one result but the TC and SC is too large here we can first sort the elements in ascending order so that the same elements are grouped together then we can jump over the duplicated element when we choose to NOT ADD it e.g. for [a,b,b], when we have already added a-&gt;b we should not add another a-&gt;b, but jump over the same elements, i.e. b Complexity analysis: TC: O(2^n) SC: O(n) Test cases:i. Test corner case: null ii. Test general case: 12, 122, 12222, 212223333 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] array) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (array == null || array.length == 0) { return result; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(array); helper(array, 0, list, result); return result;}private void helper(int[] array, int index, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) { // base case if (index == array.length) { result.add(new ArrayList&lt;&gt;(list)); return; } list.add(array[index]); helper(array, index + 1, list, result); list.remove(list.size() - 1); int i = index + 1; while (i &lt; array.length &amp;&amp; array[i] == array[index]) { i++; } helper(array, i, list, result);}","link":"/2021/08/09/subsets-ii/"}],"tags":[{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"ood","slug":"ood","link":"/tags/ood/"},{"name":"hashmap","slug":"hashmap","link":"/tags/hashmap/"},{"name":"pq","slug":"pq","link":"/tags/pq/"},{"name":"quick select","slug":"quick-select","link":"/tags/quick-select/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}