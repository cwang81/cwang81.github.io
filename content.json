{"pages":[{"title":"About me","text":"ðŸŽ‰ Code for fun! ðŸŽ‰ I am currently a Ph.D. candidate at University of Houston.My research focus is on computational catalysis and reaction modeling. I love coding/hiking/video games!This blog is used to record my ideas and LeetCode questions.Hope you have fun here!!!","link":"/about/me.html"}],"posts":[{"title":"K Smallest In Unsorted Array","text":"Clarification &amp; Assumption:Input &amp; Output (signature): i. input: int[] array, int k ii. output: int[], k smallest in ascending order For all the possible cases: input not sorted k &gt;=0, k &lt;= input.length array not null corner case: array == [], k == 0 â†’ return empty array Result:high level: 1. bfs, maxHeap (less space than minHeap) 2. quick select Queue&lt;Integer&gt; maxHeap; i = 0 to k-1 â†’ maxHeap.offer(array[i]); i = k to array.length - 1: smaller than maxHeap.peek(); maxHeap.poll(); maxHeap.offer(array[i]); int[] result; put all numbers from maxHeap to result; Complexity analysis: TC: O(k + (n-k)logk) SC: O(k) Test cases: i. Test corner case: length == 0, k == 0 â†’ return empty array ii. Test general case: 9 1 2 7 8 5 3, k = 0/1/2/3/4, etc. 1. Priority Queue12345678910111213141516171819202122public int[] kSmallest(int[] array, int k) { if (array.length == 0 || k == 0) { return new int[0]; } Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(k, (Integer i1, Integer i2) -&gt; i1.equals(i2) ? 0 : i1 &gt; i2 ? -1 : 1); for (int i = 0; i &lt; array.length; i += 1) { if (i &lt; k) { maxHeap.offer(array[i]); } else { if (array[i] &lt; maxHeap.peek()) { maxHeap.poll(); maxHeap.offer(array[i]); } } } int[] result = new int[k]; for (int i = k - 1; i &gt;= 0; i -= 1) { result[i] = maxHeap.poll(); } return result;} 2. Quick SelectComplexity analysis: TC: O(n) = n + n/2 + n/4 + â€¦ + 1 worse case: O(n^2) SC: O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445public int[] kSmallest(int[] array, int k) { if (array.length == 0 || k == 0) { return new int[0]; } int left = 0; int right = array.length - 1; while (left &lt; right) { int index = partition(array, left, right); if (index &lt; k - 1) { left = index + 1; } else if (index &gt; k - 1) { right = index - 1; } else { break; } } int[] result = Arrays.copyOf(array, k); Arrays.sort(result); return result;}private int partition(int[] array, int left, int right) { int pivotIndex = left + (int)(Math.random() * (right - left + 1)); int pivot = array[pivotIndex]; swap(array, pivotIndex, right); int i = left; int j = right - 1; while (i &lt;= j) { if (array[i] &lt; pivot) { i++; } else if (array[j] &gt;= pivot) { j--; } else { swap(array, i++, j--); } } swap(array, i, right); return i;}private void swap(int[] array, int index1, int index2) { int tmp = array[index1]; array[index1] = array[index2]; array[index2] = tmp;}","link":"/2021/08/08/k-smallest-in-unsorted-array/"},{"title":"LC 90. SubSets II","text":"Clarification &amp; Assumption:Input &amp; Output (signature): i. input: String set ii. output: List&lt;String&gt; For all the possible cases: there could be duplicate characters Result:high level: DFS i. sort the characters in ascending order to make the duplicate character next to each other ii. DFS backtracking abb â†’ '', a, b, ab, bb, abb '' / \\ 0 a '' / \\ / \\ 1 ab a b '' / \\ \\ / \\ \\ 2 abb ab a bb b '' helper(char[] array, int index, StringBuilder sb, List&lt;String&gt; list) // base case if (index == array.length) list.add(sb.toString()) return; // recursion rule sb.append(array[index]) helper(array, index + 1, sb, list) sb.deleteCharAt(sb.length() - 1) int i = index + 1 while (i &lt; array.length &amp;&amp; array[i] == array[index]) i += 1; helper(array, i, sb, list) Complexity analysis: TC: O(2^set.length()) SC: O(set.length()) Test cases:i. Test corner case: null ii. Test general case: '', abc, abb, abab, etc. 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] array) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (array == null || array.length == 0) { return result; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(array); helper(array, 0, list, result); return result;}private void helper(int[] array, int index, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) { // base case if (index == array.length) { result.add(new ArrayList&lt;&gt;(list)); return; } list.add(array[index]); helper(array, index + 1, list, result); list.remove(list.size() - 1); int i = index + 1; while (i &lt; array.length &amp;&amp; array[i] == array[index]) { i++; } helper(array, i, list, result);}","link":"/2021/08/09/subsets-ii/"},{"title":"Hello World","text":"Hello World!","link":"/2021/08/08/hello-world/"}],"tags":[{"name":"pq","slug":"pq","link":"/tags/pq/"},{"name":"quick select","slug":"quick-select","link":"/tags/quick-select/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}